
%skeleton "lalr1.cc"
%defines
%define api.namespace {rxml}

%locations
%error-verbose
/* %debug */

%code requires 
{

class XmlLexer;

#include "rxml.h"
}

%parse-param {XmlLexer& lex}
%parse-param {Document& doc}
%parse-param {std::ostream& err}
%parse-param {std::string filename}
%lex-param   {XmlLexer& lex}

%initial-action
{
    // Initialize the initial location.
    @$.begin.line = @$.end.line = 1;
    @$.begin.filename = @$.end.filename = &filename;
};

// Symbols.
%union
{    
    std::string*                         string;
    std::map<std::string, std::string>*  string_map;
    std::pair<std::string, std::string>* string_pair;
    rxml::Element*                       element;
}

%token              END 0           "end of file"
%token              ERROR           "lexing error"

%token <string>     WS              "white space"
%token <string>     NL              "new line"
%token <string>     COMMENT         "comment"
%token              LT              "<"
%token              LTS             "</"
%token              GT              ">"
%token              GTS             "/>"
%token              PIO             "<?"
%token              PIE             "?>"
%token              EQUAL           "="
%token <string>     CHARS           "character data"
%token <string>     IDENTIFIER      "identifier"
%token <string>     STRING          "string"
%token <string>     CDATA           "cdata section"

%type <string>      etag
%type <element>     stag emptytag element
%type <string_pair> attribute
%type <string_map>  attributes

%destructor { delete $$; } <string>
%destructor { delete $$; } <string_map>
%destructor { delete $$; } <string_pair>
%destructor { delete $$; } <element>

%{
int yylex(rxml::parser::semantic_type* yylval, rxml::parser::location_type* yylloc, XmlLexer& lex);

#include "XmlLexer.h"
#include <memory>

template <typename Type>
std::shared_ptr<Type> wrap(Type* type)
{
    return std::shared_ptr<Type>(type);
}
%}

%%

document:
  prolog element misc {
    doc.set_root_element(wrap($2));
  };

prolog:
  pi s | /* nothing */;
  
pi:
  "<?" IDENTIFIER s attributes s "?>" {
    // TODO     
    delete $2;
    delete $4;
  };  
  
element:
  stag content etag {
    if ($1->get_name() != *$3)
    {
        error(@1, "Tag does not match.");
        return -1;
    }
    
    $$ = $1;
    // atach content
    
  } |
  emptytag {
    $$ = $1;
  };
  
misc: 
  s |
  pi;
  
emptytag:
  "<" IDENTIFIER s attributes s "/>" {
    $$ = new Element(*$2);
    delete $2;
    delete $4;
  };
  
stag:
  "<" IDENTIFIER s attributes s ">" {
    $$ = new Element(*$2);
    delete $2;
    delete $4;
  };
  
etag:
  "</" IDENTIFIER s ">" {
    $$ = $2;
  };
  
attributes:
  attributes attribute {
    $$ = $1;
    // TODO fail if the attribute is double defined
    $$->insert(*$2);
    delete $2;
  } |
  /* nothing */ {
    $$ = new std::map<std::string, std::string>();
  };
  
attribute:
  IDENTIFIER "=" STRING {
    $$ = new std::pair<std::string, std::string>(*$1, *$3);
    delete $1;
    delete $3;
  };

content:
    content nodes |
    /* nothing */;

nodes:
  text | 
  element | 
  pi |
  cdata |
  comment; 
  
text: 
  WS | NL | CHARS | IDENTIFIER | STRING;

cdata:
  CDATA;

comment:
  COMMENT;

s:
  WS | NL | /* nothing */;
  
%%

#include <iostream>

#include "XmlLexer.h"

void rxml::parser::error(const location_type& l, const std::string& m)
{    
    err << *l.begin.filename << "(" << l.begin.line << "): " << m << std::endl;
}

int yylex(rxml::parser::semantic_type* yylval, rxml::parser::location_type* yylloc, XmlLexer& lex)
{
    return lex.lex(yylval, yylloc);
}